#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <unistd.h>
#include <sys/resource.h>
#include <unistd.h>
#include <sys/types.h>
#include <pwd.h>

int main(int argc, char **argv) {
	FILE *popen_file = NULL;
	char popen_command[4096] = {0};
	char popen_result[4096] = {0};

	int i = 0;
	while (1) {
		printf("iteration %d: \n", i++);

		// request a free online web service, see http://predic8.com/rest-demo.htm
		// sprintf(curl_command, "curl -s http://www.thomas-bayer.com/sqlrest/CUSTOMER/18/");
		sprintf(popen_command, "date");
		popen_file = (FILE *)popen(popen_command, "r");
		if (popen_file == NULL) {
			printf("popen: error no is %d, error description is %s\n", errno, strerror(errno));

			if (errno == EAGAIN) {
				// check how many process running by xiangqian, [watch "ps -u xiangqian | wc -l"]

				// show uid
				uid_t uid = getuid();
				errno = 0;			// reset before check getpwuid
				struct passwd *pw = getpwuid(uid);
				if (pw != NULL) {
					printf("username is %s, user id is %d\n", pw->pw_name, pw->pw_uid);
				} else {
					printf("getpwuid: error no is %d, error description is %s\n", errno, strerror(errno));
				}

				// show resource limit of real user id
				struct rlimit resource_limit;
				if (getrlimit(RLIMIT_NPROC, &resource_limit) == 0) {
					printf("soft limit of RLIMIT_NPROC is %lld, hard limit of RLIMIT_NPROC is %lld\n", (long long)resource_limit.rlim_cur, (long long)resource_limit.rlim_max);
				} else {
					printf("getrlimit: error no is %d, error description is %s\n", errno, strerror(errno));
				}
			} else if (errno == EMFILE) {
				// check how many file descriptor the process opened, [watch "ls -l /proc/%pid%/fd | wc -l"]
				;
			}

			exit(EXIT_FAILURE);
		}

		if (fread(popen_result, sizeof(char), sizeof(popen_result), popen_file)) {
			printf(popen_result);
		}

		pclose(popen_file);

		sleep(1);
	}

	exit(EXIT_SUCCESS);
}
